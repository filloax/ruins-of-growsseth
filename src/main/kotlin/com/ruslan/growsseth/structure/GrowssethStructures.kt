package com.ruslan.growsseth.structure

import com.ruslan.growsseth.GrowssethTags.StructTags
import com.ruslan.growsseth.structure.pieces.ResearcherTent
import com.ruslan.growsseth.structure.structure.ResearcherTentStructure
import com.ruslan.growsseth.utils.resLoc
import net.minecraft.core.registries.Registries
import net.minecraft.data.worldgen.BootstrapContext
import net.minecraft.resources.ResourceKey
import net.minecraft.resources.ResourceLocation
import net.minecraft.tags.TagKey
import net.minecraft.world.level.levelgen.structure.Structure
import net.minecraft.world.level.levelgen.structure.StructureSet
import net.minecraft.world.level.levelgen.structure.StructureType

object GrowssethStructures {
    @JvmStatic
    val all = HashSet<ResourceKey<Structure>>()
    val info = mutableMapOf<ResourceKey<Structure>, StructureInfo>()
    @JvmStatic
    val cydoniaToOriginal = mutableMapOf<ResourceKey<Structure>, ResourceKey<Structure>>()

    // Defined via data, here for reference
    @JvmField
    val RESEARCHER_TENT = make("researcher_tent", StructTags.RESEARCHER_TENT)
    @JvmField
    val RESEARCHER_TENT_SIMPLE = make("researcher_tent_simple", StructTags.RESEARCHER_TENT)
    @JvmField
    val BEEKEEPER_HOUSE = make("beekeeper_house", StructTags.BEEKEEPER_HOUSE)
    @JvmField
    val CAVE_CAMP = make("cave_camp", StructTags.CAVE_CAMP, emeraldCost = 0)
    @JvmField
    val MARKER = make("marker", StructTags.MARKER)
    @JvmField
    val GOLEM_HOUSE = make("golem_house", StructTags.GOLEM_HOUSE)
    @JvmField
    val ENCHANT_TOWER = make("enchant_tower", StructTags.ENCHANT_TOWER, emeraldCost = 7)
    @JvmField
    val ABANDONED_FORGE = make("abandoned_forge", StructTags.ABANDONED_FORGE)
    @JvmField
    val CONDUIT_RUINS = make("conduit_ruins", StructTags.CONDUIT_RUINS)
    @JvmField
    val CONDUIT_CHURCH = make("conduit_church", StructTags.CONDUIT_CHURCH, emeraldCost = 7)
    @JvmField
    val NOTEBLOCK_LAB = make("noteblock_lab", StructTags.NOTEBLOCK_LAB)
    @JvmField
    val NOTEBLOCK_SHIP = make("noteblock_ship", StructTags.NOTEBLOCK_SHIP)

    // Structures findable by map in the original live run, used for progress modes
    val ORIGINAL_STRUCTURES = listOf(
        CAVE_CAMP,
        GOLEM_HOUSE,
        ENCHANT_TOWER,
        NOTEBLOCK_LAB,
        BEEKEEPER_HOUSE,
        CONDUIT_CHURCH,
    )

    // Structures with structure sets
    val SPAWNS_NATURALLY = listOf(
        CAVE_CAMP,
        GOLEM_HOUSE,
        ENCHANT_TOWER,
        NOTEBLOCK_LAB,
        BEEKEEPER_HOUSE,
        CONDUIT_CHURCH,
        RESEARCHER_TENT,
        RESEARCHER_TENT_SIMPLE,
        NOTEBLOCK_SHIP,
        ABANDONED_FORGE,
        CONDUIT_RUINS,
    )

    init {
        // random statement to make sure the loader loads the GolemStandaloneVariants obj
        GolemStandaloneVariants.GOLEM_HOUSE_SNOWY
    }

    // autogenerated this part via python lol
    object GolemStandaloneVariants {
        @JvmField
        val GOLEM_HOUSE_SNOWY = make("golem_variants/snowy_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_TAIGA = make("golem_variants/taiga_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_DESERT = make("golem_variants/desert_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_PLAINS = make("golem_variants/plains_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_SAVANNA = make("golem_variants/savanna_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_ZOMBIE_DESERT = make("golem_variants/zombie_desert_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_ZOMBIE_PLAINS = make("golem_variants/zombie_plains_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_ZOMBIE_SAVANNA = make("golem_variants/zombie_savanna_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_ZOMBIE_SNOWY = make("golem_variants/zombie_snowy_golem_house", StructTags.GOLEM_HOUSE)
        @JvmField
        val GOLEM_HOUSE_ZOMBIE_TAIGA = make("golem_variants/zombie_taiga_golem_house", StructTags.GOLEM_HOUSE)
    }

    object CydoniaVersion {
        @JvmField
        val RESEARCHER_TENT = makeCydonia("researcher_tent", GrowssethStructures.RESEARCHER_TENT)
        @JvmField
        val BEEKEEPER_HOUSE = makeCydonia("beekeeper_house", GrowssethStructures.BEEKEEPER_HOUSE)
        @JvmField
        val CAVE_CAMP = makeCydonia("cave_camp", GrowssethStructures.CAVE_CAMP)
        @JvmField
        val MARKER = makeCydonia("marker", GrowssethStructures.MARKER)
        @JvmField
        val GOLEM_HOUSE = makeCydonia("golem_house", GrowssethStructures.GOLEM_HOUSE)
        @JvmField
        val ENCHANT_TOWER = makeCydonia("enchant_tower", GrowssethStructures.ENCHANT_TOWER)
        @JvmField
        val CONDUIT_CHURCH = makeCydonia("conduit_church", GrowssethStructures.CONDUIT_CHURCH)
        @JvmField
        val NOTEBLOCK_LAB = makeCydonia("noteblock_lab", GrowssethStructures.NOTEBLOCK_LAB)
    }

    object Types {
        @JvmStatic
        val all = mutableMapOf<ResourceLocation, StructureType<*>>()

        val RESEARCHER_TENT = registerType("researcher_tent") { ResearcherTentStructure.CODEC }

        private fun <T : Structure> registerType(name: String, type: StructureType<T>): StructureType<T> {
            val id = resLoc(name)
            all[id] = type
            return type
        }
    }

    fun registerStructureTypes(registrator: (ResourceLocation, StructureType<*>) -> Unit) {
        Types.all.forEach{
            registrator(it.key, it.value)
        }
    }

    // Note: assumes that structures with a structures set have the same id
    fun getStructureSetId(structId: ResourceKey<Structure>): ResourceKey<StructureSet>? {
        return if (SPAWNS_NATURALLY.contains(structId)) {
            ResourceKey.create(Registries.STRUCTURE_SET, structId.location())
        } else {
            null
        }
    }

    private fun make(name: String, tag: TagKey<Structure>, emeraldCost: Int = 5): ResourceKey<Structure> {
        val key = ResourceKey.create(Registries.STRUCTURE, resLoc(name))
        all.add(key)
        info[key] = StructureInfo(key, tag, emeraldCost)
        return key
    }

    private fun makeCydonia(name: String, base: ResourceKey<Structure>): ResourceKey<Structure> {
        val key = make("cydonia/$name", info[base]!!.tag)
        cydoniaToOriginal[key] = base
        return key
    }

    class Bootstrapper(private val ctx: BootstrapContext<Structure>) {
        // TODO: switch all structures to datagen so datagen for tags etc works properly
//        private fun registerSimpleJigsaw(key: ResourceKey<Structure>) {
//            context.register(
//                BuiltinStructures.VILLAGE_PLAINS, JigsawStructure(
//                    Structures.structure(
//                        holderGetter.getOrThrow(BiomeTags.HAS_VILLAGE_PLAINS), TerrainAdjustment.BEARD_THIN
//                    ), holderGetter2.getOrThrow(PlainVillagePools.START), 6,
//                    ConstantHeight.of(VerticalAnchor.absolute(0)), true, Heightmap.Types.WORLD_SURFACE_WG
//                )
//            )
//        }

        private fun registerTents() {
            ctx.register(RESEARCHER_TENT, ResearcherTentStructure.build(ctx))
            ctx.register(RESEARCHER_TENT_SIMPLE, ResearcherTentStructure.build(ctx, ResearcherTent.SIMPLE_ID, 0))
            ctx.register(CydoniaVersion.RESEARCHER_TENT, ResearcherTentStructure.build(ctx, ResearcherTent.CYDONIA_ID))
        }

        // Used in data generation
        fun bootstrap() {
            registerTents()
        }
    }
    fun bootstrap(ctx: BootstrapContext<Structure>) = Bootstrapper(ctx).bootstrap()

    data class StructureInfo(
        val key: ResourceKey<Structure>,
        val tag: TagKey<Structure>,
        val emeraldCost: Int,
    )
}